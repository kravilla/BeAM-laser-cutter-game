<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - geometry - extrude shapes from geodata</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <script type="text/javascript" src="../../jquery-3.3.1.js"></script>
  <script type="text/javascript" src="../../paperjs/dist/paper-full.js"></script>
  <script type="text/javascript" src="js/three.js"></script>

  <script type="text/javascript" src="js/d3-threeD.js"></script>
  <script type="text/javascript" src="js/Project.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/stats.min.js"></script>
</head>

<body>

  <div id="container"></div>
  <div id="other"></div>
  <div >
    <canvas id="pa"> </canvas>
  </div>


  <script>

  $(document).ready(function(){
    paper.setup('pa');

    var addGeoObject = function( group, svgObject ) {

      var cutting = svgObject.filter(function(e){
        return e.func =="cutting";
      })

      var rastering = svgObject.filter(function(e){
        return e.func =="rastering";
      })

      var etching = svgObject.filter(function(e){
        return e.func =="etching";
      })

      var t = new Path();
      $.each(cutting, function(k,v){
        var p;
        switch (v.type) {
          case 'path':
              p = SVGtransform.transformSVGPathPAPER(v.d);
            break;
          case 'circle':
             p = SVGtransform.transformSVGCirclePAPER(v.cx, v.cy,v.r);
          break;
        }
        t = t.unite(p.path);
      })

      var outline = SVGtransform.transformSVGPathTHREE(t.pathData).path;
      var outline_shape = outline.toShapes(true, false);
      t.bounds.topLeft = new Point(3,3);
      t.strokeColor = 'black';
      $.each(cutting, function(k,v){
        var p;
        switch (v.type) {
          case 'path':
              p = SVGtransform.transformSVGPathPAPER(v.d);
            break;
          case 'circle':
             p = SVGtransform.transformSVGCirclePAPER(v.cx, v.cy,v.r);
          break;
        }
        p = p.path;

        $.each(t.children, function (index,shape){
          if(shape.contains(p.segments[0].point)){
            if(shape.getIntersections(p).length==0){
              outline_shape[index].holes.push(SVGtransform.transformSVGPathTHREE(p.pathData).path.subPaths[0]);
            }
            return false;
          }
        })
      })

      $.each(rastering, function(k,v){
        var p, pp;
        switch (v.type) {
          case 'path':
              p = SVGtransform.transformSVGPathTHREE(v.d);
              pp = SVGtransform.transformSVGPathPAPER(v.d).path;
            break;
          case 'circle':
             p = SVGtransform.transformSVGCircleTHREE(v.cx, v.cy,v.r);
             pp = SVGtransform.transformSVGCirclePAPER(v.cx, v.cy,v.r).path;
          break;
        }
        var p_shape = p.path.toShapes(true, true);
        var color = new THREE.Color(0x996600);
        var material = new THREE.MeshLambertMaterial( {
          color: color,
        } );
        var shape3d = new THREE.ExtrudeBufferGeometry( p_shape, {
          amount: 18,
          bevelEnabled: false
        } );

        $.each(t.children, function (index,shape){
          if(shape.contains(pp.segments[0].point)){
              outline_shape[index].holes.push(p.path.subPaths[0]);
            return false;
          }
        })
        var mesh = new THREE.Mesh( shape3d, material );
        mesh.translateZ(-18);
        group.add( mesh );
      })

      $.each(etching, function (k,v){
        var p;
        switch (v.type) {
          case 'path':
              p = SVGtransform.transformSVGPathPAPER(v.d).path;
            break;
          case 'circle':
             p = SVGtransform.transformSVGCirclePAPER(v.cx, v.cy,v.r).path;
          break;
        }

        var et = new Path();
        var iter = p.firstSegment;
        var nor = p.getNormalAt(p.getOffsetOf(iter.point));
        var seg = new Segment({
          point: iter.point.add(nor.divide(4))
        });
        et.add(seg);
        while(!iter.isLast()){
          iter = iter.next;
          nor = p.getNormalAt(p.getOffsetOf(iter.point));
          seg = new Segment({
            point: iter.point.add(nor.divide(4)),
            handleIn: iter.handleIn,
            handleOut: iter.handleOut
          });
          et.add(seg);
        }
        seg.clearHandles();
        seg = new Segment({
          point: iter.point.subtract(nor.divide(4))
        });
        et.add(seg);
        while(!iter.isFirst()){
          iter = iter.previous;
          nor = p.getNormalAt(p.getOffsetOf(iter.point));
          seg = new Segment({
            point: iter.point.subtract(nor.divide(4)),
            handleIn: iter.handleOut,
            handleOut: iter.handleIn
          });
          et.add(seg);
        }
        seg.clearHandles();
        et.closePath();
        var threed = SVGtransform.transformSVGPathTHREE(et.pathData).path;
        var etch_shape = threed.toShapes(true, true);
        var color = new THREE.Color(0x996600);
        var material = new THREE.MeshLambertMaterial( {
          color: color,
        } );
        var shape3d = new THREE.ExtrudeBufferGeometry( etch_shape, {
          amount: 10,
          bevelEnabled: false
        } );
        var mesh = new THREE.Mesh( shape3d, material );
        mesh.translateZ(-10);
        group.add( mesh );


        $.each(t.children, function (index,shape){
          if(shape.contains(et.segments[0].point)){
            if(shape.getIntersections(et).length==0){
              outline_shape[index].holes.push(threed.subPaths[0]);
            }
            return false;
          }
        })


      })


      $.each(outline_shape, function(k, sh){
        var color = new THREE.Color(0xffeecc);
        var material = new THREE.MeshLambertMaterial( {
          color: color,
        } );
        var shape3d = new THREE.ExtrudeBufferGeometry( sh, {
          amount: 25,
          bevelEnabled: false
        } );
        var mesh = new THREE.Mesh( shape3d, material );

        mesh.translateZ(-25);
        group.add( mesh );
      })

      group.rotateZ(Math.PI);
      group.rotateY(Math.PI);
      group.translateX(-150);
      group.translateY(-50);


    };

    var renderer, stats, scene, camera;

    init();
    animate();

    function init() {

      var container = document.getElementById( 'container' );

      scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xb0b0b0 );

      camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
      camera.position.set( 0, 0, 400 );

      var group = new THREE.Group();
      scene.add( group );

      var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.6 );
      directionalLight.position.set( 0.75, 0.75, 1.0 ).normalize();
      scene.add( directionalLight );

      var ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
      scene.add( ambientLight );

      //
      //
      // var helper = new THREE.GridHelper( 400, 200 );
      // helper.rotation.x = Math.PI / 2;
      // group.add( helper );

      //
      var obj = getDesign(Mode.tutorial);
      addGeoObject( group, obj );


      //

      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );

      //

      var controls = new THREE.OrbitControls( camera, renderer.domElement );

      //

      stats = new Stats();
      container.appendChild( stats.dom );

      //

      window.addEventListener( 'resize', onWindowResize, false );

    }
    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {

      requestAnimationFrame( animate );

      render();
      stats.update();

    }

    function render() {

      renderer.render( scene, camera );

    }

  })



  </script>

</body>
</html>
