<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - geometry - extrude shapes from geodata</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <script type="text/javascript" src="../../jquery-ui/external/jquery.js"></script>
  <script type="text/javascript" src="../../paperjs/dist/paper-full.js"></script>
  <script type="text/javascript" src="js/three.js"></script>
  <script type="text/javascript" src="js/d3-threeD.js"></script>
  <script type="text/javascript" src="js/Project.js"></script>
  <script type="text/javascript" src="js/offset.js"></script>

  <script src="js/OrbitControls.js"></script>
  <style>
    #modelContainer {
      position: absolute;
      width: 1280px;
      height:800px;
      top:0;
      bottom: 0;
      left: 0;
      right:0;
      margin: auto;
      background: url("scene_pics/scene1.png") no-repeat center top;
      -webkit-background-size: contain;
      -moz-background-size: contain;
      -o-background-size: contain;
      background-size: contain;
      overflow: hidden;
    }

    #modelCanvasContainer {
      position: absolute;
      width: 50%;
      height:50%;
      top: 25%;
      left: 10%;
    }

    #modelCloseButton {
      position: absolute;
      right: 10%;
      bottom: 10%;
    }

  </style>
</head>

<body>
  <div id="modelContainer" >
    <div id="modelCanvasContainer" ></div>
    <div id="modelInfo"></div>
    <button id="modelCloseButton" onclick="window.close()">Close</button>
  </div>
  <div id="other" style="display: none"><canvas width="1000" height="1000" id='pa'></canvas></div>
  <script>

  window.onresize = function(event) {
    resize();
  }
  function etchShape3 (v) {
    var outerPath, innerPath, res;
    var offset = 0.5;

    if(v.closed){
      var first = new Segment({
        point:v.getPointAt(1),
        handleOut: v.firstSegment.handleOut
      });
      var last = new Segment({
        point:v.firstSegment.point.clone(),
        handleIn: v.firstSegment.handleIn
      })
      v.closed = false;
      v.add(last);
      v.removeSegment(0);
      v.insert(0,first);

    }

    outerPath = OffsetUtils.offsetPath(v, offset, true);
    innerPath = OffsetUtils.offsetPath(v, -offset, true);

    outerPath.reverse();
    res = outerPath.join(innerPath);

    res.closePath();
    res = res.unite(res);
    res.reorient(false,true);
    if(res.className == "CompoundPath"){
      var r = res.lastChild.clone();
      r.splitAt(1);
      var ta = r.getTangentAt(1);
      r.lastSegment.clearHandles();
      var t = res.firstChild.clone();
      t.reorient(false,true);
      var p = t.getNearestLocation(r.firstSegment.point);
      t.splitAt(p);
      t.firstSegment.clearHandles();

      r.join(t);

      var sg =  r.lastSegment.point.add(ta);
      var sg2 = r.firstSegment.point.add(ta);
      r.removeSegment(r.segments.length-1);
      r.add(sg);

      r.removeSegment(0);
      r.insert(0,sg2);
      r.reorient(false,true);
      r.closePath();
      res.remove();

      res = r;
    }

    return res;
  }
  function resize(){
    var vpw = $(window).width();
    var vph = $(window).height();
    var w = vph*1280/800;
    if(vpw>w){
      vpw=w;
    }else{
      vph = vpw*800/1280;
    }

    if (vph<400){
      vph = 400;
      vpw=640;
    }
    $("#modelContainer").css({
      "height": vph + "px",
      "width" : vpw + "px"
    });

  }
  resize();
  var des = window.opener.g_design;


  $(document).ready(function(){
    paper.setup('pa');

    function getDesign(designgroup){
      var re = [];
      $.each(designgroup, function(ind, shape){
        console.log(ind );
        if(shape.visible && shape.data.fill.depth==0 && shape.data.edge.depth>0 && shape.data.edge.type!='cutting'){
          var t = etchShape3(shape);
          t.data.fill = {};
          t.data.fill.depth = shape.data.edge.depth;
          t.data.fill.darkness = shape.data.edge.darkness;
          re.push(t);
        }else if (shape.visible){
          re.push(shape);
        }
      });
      return re;
    }

    var addGeoObject = function( group, svgObject ) {
      var pathN = svgObject.length;
      var confirmed_area = new Path();
      var t = new Path();
      var woodMaterial = new THREE.MeshLambertMaterial( {
        color: new THREE.Color(0xffeecc)
      } );

      var cutting = svgObject.filter(function(e){
        if(e.data.edge){
          return e.data.edge.type =="cutting";
        }else{
          return false;
        }
      })

      $.each(cutting, function(k,v){
        t = t.unite(v);
      })
      var outline = SVGtransform.transformSVGPathTHREE(t.pathData).path;
      var outline_shape = outline.toShapes(true, true);

      $.each(svgObject, function(k,v){
        if(t.children){
          $.each(t.children, function (index,shape){
            if(shape.contains(v.segments[0].point) && shape.getIntersections(v)==0){
              outline_shape[index].holes.push(SVGtransform.transformSVGPathTHREE(v.pathData).path.subPaths[0]);
              return false;
            }
          })
        }else if(t.getIntersections(v)==0){
          var paths = SVGtransform.transformSVGPathTHREE(v.pathData).path.subPaths;
          $.each(paths, function(v, path){
            outline_shape[0].holes.push(path);
          })
        }
      })

      $.each(outline_shape, function(k, sh){
        var shape3d = new THREE.ExtrudeBufferGeometry( sh, {
          amount: 25.5,
          bevelEnabled: false
        } );
        var mesh = new THREE.Mesh( shape3d, woodMaterial );
        group.add( mesh );
      })
      // $.each(outline_shape, function(k, sh){
      //   var shape3d = new THREE.ShapeBufferGeometry( sh);
      //   var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      //   var mesh = new THREE.Mesh( shape3d, material );
      //   group.add( mesh );
      // })

      for ( var i = pathN-1; i >-1; i--){
        var p = svgObject[i];
        var tem, newpart, dep;
        var threeData,color,material, shape3d, mesh;
        if(p.data.fill.depth!=0){
          newpart = p.subtract(confirmed_area);
          confirmed_area = confirmed_area.unite(p);
          console.log(i+":  confirmed_area:" +confirmed_area.area + "    newpart:" +newpart.area);
          dep = p.data.fill.depth*100;
          threeData = SVGtransform.transformSVGPathTHREE(p.pathData).path.toShapes(true, true);
          console.log(p.area);

          color = new THREE.Color(0x996600);
          material = new THREE.MeshLambertMaterial( {
            color: color,
          } );
          shape3d = new THREE.ExtrudeBufferGeometry( threeData, {
            amount: 25.5-dep,
            bevelEnabled: false
          } );
          mesh = new THREE.Mesh( shape3d, [material,woodMaterial,woodMaterial, woodMaterial]);
          mesh.translateZ(dep);
          group.add( mesh );
        }

      }

      group.rotateZ(Math.PI);
      group.rotateY(Math.PI);
      group.translateX(-(t.bounds.x+t.bounds.width/2));
      group.translateY(-(t.bounds.y+t.bounds.height/2));


    };

    var renderer, scene, camera;

    init();
    animate();

    function init() {

      var container = document.getElementById( 'modelCanvasContainer' );

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera( 50, 1280 / 800, 1, 10000 );
      camera.position.set( 0, 0, 500 );

      axesHelper = new THREE.AxesHelper( 5 );
      scene.add( axesHelper );

      var group = new THREE.Group();
      scene.add( group );

      var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.6 );
      directionalLight.position.set( 0.75, 0.75, 1.0 ).normalize();
      scene.add( directionalLight );

      var ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
      scene.add( ambientLight );

      //var geo = getDesign(des);

      addGeoObject( group, des );


      renderer = new THREE.WebGLRenderer( {
        antialias: true,
        alpha: true
      } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( $("#modelCanvasContainer").width(), $("#modelCanvasContainer").height() );
      renderer.setClearColor( 0x000000, 0 );
      container.appendChild( renderer.domElement );

      //

      var controls = new THREE.OrbitControls( camera, renderer.domElement );
      //

      window.addEventListener( 'resize', onWindowResize, false );

    }
    function onWindowResize() {
      camera.updateProjectionMatrix();

      renderer.setSize( $("#modelCanvasContainer").width(), $("#modelCanvasContainer").height() );

    }

    function animate() {

      requestAnimationFrame( animate );

      render();

    }

    function render() {

      renderer.render( scene, camera );

    }

  })



  </script>

</body>
</html>
